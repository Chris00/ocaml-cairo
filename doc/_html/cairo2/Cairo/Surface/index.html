<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Surface (cairo2.Cairo.Surface)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">cairo2</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Cairo.Surface</span></h1></header><div class="doc"><p>Abstract representation of all different drawing targets that
cairo can render to; the actual drawings are performed using a
cairo context.</p></div><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code></code><code></code></div><div class="doc"><p>A <a href="index.html#type-t">Cairo.Surface.t</a> represents an image, either as the
destination of a drawing operation or as source when drawing onto
another surface. To draw to a <a href="index.html#type-t">Cairo.Surface.t</a>, create a cairo
context with the surface as the target, using <a href="../index.html#val-create">Cairo.create</a>.</p><p>There are different subtypes of <a href="index.html#type-t">Cairo.Surface.t</a> for
different drawing backends; for example, <a href="../Image/index.html#val-create">Cairo.Image.create</a>
creates a bitmap image in memory. The type of a surface can be
queried with <a href="index.html#val-get_type">Cairo.Surface.get_type</a>.</p></div></div><div class="spec val" id="val-create_similar"><a href="#val-create_similar" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>create_similar : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-content">content</a> <span class="keyword">&#8209;&gt;</span> w:int <span class="keyword">&#8209;&gt;</span> h:int <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">create_similar other content width height</code> create a new surface
that is as compatible as possible with the existing surface
<code class="code">other</code>. For example the new surface will have the same fallback
resolution and font options as <code class="code">other</code>. Generally, the new
surface will also use the same backend as other, unless that is
not possible for some reason. The type of the returned surface
may be examined with <a href="index.html#val-get_type">Cairo.Surface.get_type</a>.</p><p>Initially the surface contents are all 0 (transparent if contents
have transparency, black otherwise.)</p></div></div><div class="spec val" id="val-finish"><a href="#val-finish" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>finish : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>This function finishes the surface and drops all references to
external resources. For example, for the Xlib backend it means
that cairo will no longer access the drawable. After calling
<a href="index.html#val-finish">Cairo.Surface.finish</a> the only valid operations on a surface
are flushing and finishing it. Further drawing to the surface
will not affect the surface but will instead raise
<code class="code">Error(SURFACE_FINISHED)</code>.</p></div></div><div class="spec val" id="val-flush"><a href="#val-flush" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>flush : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>Do any pending drawing for the surface and also restore any
temporary modification's cairo has made to the surface's state.
This function must be called before switching from drawing on the
surface with cairo to drawing on it directly with native APIs.
If the surface doesn't support direct access, then this function
does nothing.</p></div></div><div class="spec val" id="val-get_font_options"><a href="#val-get_font_options" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_font_options : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="../Font_options/index.html#type-t">Font_options.t</a></code></div><div class="doc"><p><code class="code">get_font_options surface</code> retrieves the default font rendering
options for the <code class="code">surface</code>. This allows display surfaces to
report the correct subpixel order for rendering on them, print
surfaces to disable hinting of metrics and so forth. The result
can then be used with <a href="../Scaled_font/index.html#val-create">Cairo.Scaled_font.create</a>.</p></div></div><div class="spec val" id="val-get_content"><a href="#val-get_content" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_content : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-content">content</a></code></div><div class="doc"><p>This function returns the content type of surface which
indicates whether the surface contains color and/or alpha
information. See <a href="../index.html#type-content">Cairo.content</a>.</p></div></div><div class="spec val" id="val-mark_dirty"><a href="#val-mark_dirty" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mark_dirty : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>Tells cairo that drawing has been done to surface using means
other than cairo, and that cairo should reread any cached areas.
Note that you must call <a href="index.html#val-flush">Cairo.Surface.flush</a> before doing such
drawing.</p></div></div><div class="spec val" id="val-mark_dirty_rectangle"><a href="#val-mark_dirty_rectangle" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mark_dirty_rectangle : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> w:int <span class="keyword">&#8209;&gt;</span> h:int <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">mark_dirty_rectangle x y w h</code> like <a href="index.html#val-mark_dirty">Cairo.Surface.mark_dirty</a>,
but drawing has been done only to the specified rectangle, so
that cairo can retain cached contents for other parts of the surface.</p><p>Any cached clip set on the surface will be reset by this
function, to make sure that future cairo calls have the clip set
that they expect.</p></div></div><div class="spec val" id="val-set_device_offset"><a href="#val-set_device_offset" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>set_device_offset : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>Sets an offset that is added to the device coordinates
determined by the CTM when drawing to surface. One use case for
this function is when we want to create a <a href="index.html#type-t">Cairo.Surface.t</a> that
redirects drawing for a portion of an onscreen surface to an
offscreen surface in a way that is completely invisible to the
user of the cairo API. Setting a transformation via
<a href="../index.html#val-translate">Cairo.translate</a> isn't sufficient to do this, since functions
like <a href="../index.html#val-device_to_user">Cairo.device_to_user</a> will expose the hidden offset.</p><p>Note that the offset affects drawing to the surface as well
as using the surface in a source pattern.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">x</span>: the offset in the X direction, in device units.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: the offset in the Y direction, in device units.</li></ul></div></div><div class="spec val" id="val-get_device_offset"><a href="#val-get_device_offset" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_device_offset : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> float<span class="keyword"> * </span>float</code></div><div class="doc"><p>This function returns the previous device offset set by
<a href="index.html#val-set_device_offset">Cairo.Surface.set_device_offset</a>.</p></div></div><div class="spec val" id="val-set_fallback_resolution"><a href="#val-set_fallback_resolution" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>set_fallback_resolution : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> x:float <span class="keyword">&#8209;&gt;</span> y:float <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">set_fallback_resolution surface x_pixels_per_inch
     y_pixels_per_inch</code> sets the horizontal and vertical resolution
for image fallbacks.</p><p>When certain operations aren't supported natively by a backend,
cairo will fallback by rendering operations to an image and then
overlaying that image onto the output. For backends that are
natively vector-oriented, this function can be used to set the
resolution used for these image fallbacks (larger values will
result in more detailed images, but also larger file sizes).</p><p>Some examples of natively vector-oriented backends are the ps,
pdf, and svg backends.</p><p>For backends that are natively raster-oriented, image fallbacks
are still possible, but they are always performed at the native
device resolution. So this function has no effect on those
backends.</p><p>Note: The fallback resolution only takes effect at the time of
completing a page (with <a href="../index.html#val-show_page">Cairo.show_page</a> or <a href="../index.html#val-copy_page">Cairo.copy_page</a>)
so there is currently no way to have more than one fallback
resolution in effect on a single page.</p><p>The default fallback resoultion is 300 pixels per inch in both
dimensions.</p></div></div><div class="spec val" id="val-get_fallback_resolution"><a href="#val-get_fallback_resolution" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_fallback_resolution : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> float<span class="keyword"> * </span>float</code></div><div class="doc"><p>This function returns the previous fallback resolution set by
<a href="index.html#val-set_fallback_resolution">Cairo.Surface.set_fallback_resolution</a>, or default fallback
resolution if never set.</p></div></div><div class="spec type" id="type-kind"><a href="#type-kind" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>kind</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-kind.Image" class="anchored"><td class="def constructor"><a href="#type-kind.Image" class="anchor"></a><code><span class="keyword">| </span></code><code>`Image</code></td></tr><tr id="type-kind.PDF" class="anchored"><td class="def constructor"><a href="#type-kind.PDF" class="anchor"></a><code><span class="keyword">| </span></code><code>`PDF</code></td></tr><tr id="type-kind.PS" class="anchored"><td class="def constructor"><a href="#type-kind.PS" class="anchor"></a><code><span class="keyword">| </span></code><code>`PS</code></td></tr><tr id="type-kind.XLib" class="anchored"><td class="def constructor"><a href="#type-kind.XLib" class="anchor"></a><code><span class="keyword">| </span></code><code>`XLib</code></td></tr><tr id="type-kind.XCB" class="anchored"><td class="def constructor"><a href="#type-kind.XCB" class="anchor"></a><code><span class="keyword">| </span></code><code>`XCB</code></td></tr><tr id="type-kind.GLITZ" class="anchored"><td class="def constructor"><a href="#type-kind.GLITZ" class="anchor"></a><code><span class="keyword">| </span></code><code>`GLITZ</code></td></tr><tr id="type-kind.Quartz" class="anchored"><td class="def constructor"><a href="#type-kind.Quartz" class="anchor"></a><code><span class="keyword">| </span></code><code>`Quartz</code></td></tr><tr id="type-kind.Win32" class="anchored"><td class="def constructor"><a href="#type-kind.Win32" class="anchor"></a><code><span class="keyword">| </span></code><code>`Win32</code></td></tr><tr id="type-kind.BEOS" class="anchored"><td class="def constructor"><a href="#type-kind.BEOS" class="anchor"></a><code><span class="keyword">| </span></code><code>`BEOS</code></td></tr><tr id="type-kind.DirectFB" class="anchored"><td class="def constructor"><a href="#type-kind.DirectFB" class="anchor"></a><code><span class="keyword">| </span></code><code>`DirectFB</code></td></tr><tr id="type-kind.SVG" class="anchored"><td class="def constructor"><a href="#type-kind.SVG" class="anchor"></a><code><span class="keyword">| </span></code><code>`SVG</code></td></tr><tr id="type-kind.OS2" class="anchored"><td class="def constructor"><a href="#type-kind.OS2" class="anchor"></a><code><span class="keyword">| </span></code><code>`OS2</code></td></tr><tr id="type-kind.Win32_printing" class="anchored"><td class="def constructor"><a href="#type-kind.Win32_printing" class="anchor"></a><code><span class="keyword">| </span></code><code>`Win32_printing</code></td></tr><tr id="type-kind.Quartz_image" class="anchored"><td class="def constructor"><a href="#type-kind.Quartz_image" class="anchor"></a><code><span class="keyword">| </span></code><code>`Quartz_image</code></td></tr><tr id="type-kind.Recording" class="anchored"><td class="def constructor"><a href="#type-kind.Recording" class="anchor"></a><code><span class="keyword">| </span></code><code>`Recording</code></td></tr></table><code> ]</code><code></code></div><div class="doc"><p>This is used to describe the type of a given surface. The
surface types are also known as &quot;backends&quot; or &quot;surface backends&quot;
within cairo.</p><p>The type of a surface is determined by the function used to
create it, which will generally be of the form <code class="code">cairo_</code><i>type</i><code class="code">_surface_create</code> (though see <a href="index.html#val-create_similar">Cairo.Surface.create_similar</a>
as well).</p></div></div><div class="spec val" id="val-get_type"><a href="#val-get_type" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_type : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-kind">kind</a></code></div><div class="doc"><p>This function returns the type of the backend used to create a
surface. See <a href="index.html#type-kind">Cairo.Surface.kind</a> for available types.</p></div></div><div class="spec val" id="val-copy_page"><a href="#val-copy_page" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>copy_page : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>Emits the current page for backends that support multiple pages,
but doesn't clear it, so that the contents of the current page
will be retained for the next page. Use
<a href="index.html#val-show_page">Cairo.Surface.show_page</a> if you want to get an empty page after
the emission.</p><p>There is a convenience function for this that takes a
<a href="../index.html#type-context">Cairo.context</a>, namely <a href="../index.html#val-copy_page">Cairo.copy_page</a>.</p></div></div><div class="spec val" id="val-show_page"><a href="#val-show_page" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>show_page : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>Emits and clears the current page for backends that support
multiple pages. Use <a href="index.html#val-copy_page">Cairo.Surface.copy_page</a> if you don't want
to clear the page.</p><p>There is a convenience function for this that takes a
<a href="../index.html#type-context">Cairo.context</a>, namely <a href="../index.html#val-show_page">Cairo.show_page</a>.</p></div></div><div class="spec val" id="val-has_show_text_glyphs"><a href="#val-has_show_text_glyphs" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>has_show_text_glyphs : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p>Returns whether the surface supports sophisticated
<a href="../Glyph/index.html#val-show_text">Cairo.Glyph.show_text</a> operations. That is, whether it
actually uses the provided text and cluster data to a
<a href="../Glyph/index.html#val-show_text">Cairo.Glyph.show_text</a> call.</p><p>Note: Even if this function returns <code class="code">false</code>, a
<a href="../Glyph/index.html#val-show_text">Cairo.Glyph.show_text</a> operation targeted at surface will still
succeed. It just will act like a <a href="../Glyph/index.html#val-show">Cairo.Glyph.show</a> operation.
Users can use this function to avoid computing UTF-8 text and
cluster mapping if the target surface does not use it.</p></div></div></body></html>