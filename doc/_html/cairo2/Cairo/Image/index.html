<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Image (cairo2.Cairo.Image)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">cairo2</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Cairo.Image</span></h1></header><div class="doc"><p>Image surfaces provide the ability to render to memory buffers
either allocated by cairo or by the calling code. The supported
image formats are those defined in <a href="index.html#type-format">Cairo.Image.format</a>.</p></div><div class="spec type" id="type-format"><a href="#type-format" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>format</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-format.ARGB32" class="anchored"><td class="def constructor"><a href="#type-format.ARGB32" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">ARGB32</span></code></td><td class="doc"><p>(** each pixel is a 32-bit quantity, with alpha in the
upper 8 bits, then red, then green, then blue. The
32-bit quantities are stored native-endian.
Pre-multiplied alpha is used. (That is, 50%
transparent red is 0x80800000, not 0x80ff0000.) *)</p></td></tr><tr id="type-format.RGB24" class="anchored"><td class="def constructor"><a href="#type-format.RGB24" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">RGB24</span></code></td><td class="doc"><p>(** each pixel is a 32-bit quantity, with the upper 8 bits
unused. Red, Green, and Blue are stored in the
remaining 24 bits in that order. *)</p></td></tr><tr id="type-format.A8" class="anchored"><td class="def constructor"><a href="#type-format.A8" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">A8</span></code></td><td class="doc"><p>(** each pixel is a 8-bit quantity holding an alpha value. *)</p></td></tr><tr id="type-format.A1" class="anchored"><td class="def constructor"><a href="#type-format.A1" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">A1</span></code></td><td class="doc"><p>(** each pixel is a 1-bit quantity holding an alpha
value. Pixels are packed together into 32-bit quantities.
The ordering of the bits matches the endianess of the
platform. On a big-endian machine, the first pixel is in
the uppermost bit, on a little-endian machine the first
pixel is in the least-significant bit. *)</p></td></tr></table><code></code></div><div class="doc"><p>This is used to identify the memory format of image data.</p></div></div><div class="spec val" id="val-create"><a href="#val-create" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>create : <a href="index.html#type-format">format</a> <span class="keyword">&#8209;&gt;</span> w:int <span class="keyword">&#8209;&gt;</span> h:int <span class="keyword">&#8209;&gt;</span> <a href="../Surface/index.html#type-t">Surface.t</a></code></div><div class="doc"><p>Creates an image surface of the specified format and
dimensions. Initially the surface contents are all 0.
(Specifically, within each pixel, each color or alpha channel
belonging to format will be 0. The contents of bits within a
pixel, but not belonging to the given format are undefined).</p></div></div><div class="spec type" id="type-data8"><a href="#type-data8" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>data8</code><code><span class="keyword"> = </span>(int, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t</code><code></code></div><div class="doc"><p>Images represented as an array of 8 bytes values.</p></div></div><div class="spec type" id="type-data32"><a href="#type-data32" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>data32</code><code><span class="keyword"> = </span>(int32, Bigarray.int32_elt, Bigarray.c_layout) Bigarray.Array2.t</code><code></code></div><div class="doc"><p>Images represented as an array of 32 bytes (RGB or RGBA) values.</p></div></div><div class="spec val" id="val-create_for_data8"><a href="#val-create_for_data8" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>create_for_data8 : <a href="index.html#type-data8">data8</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;stride:int <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-format">format</a> <span class="keyword">&#8209;&gt;</span> w:int <span class="keyword">&#8209;&gt;</span> h:int <span class="keyword">&#8209;&gt;</span> <a href="../Surface/index.html#type-t">Surface.t</a></code></div><div class="doc"><p><code class="code">create_for_data8 data format ?stride width height</code> creates an
image surface for the provided pixel data. The initial contents
of buffer will be used as the initial image contents; you must
explicitly clear the buffer, using, for example,
<a href="../index.html#type-rectangle">Cairo.rectangle</a> and <a href="../index.html#val-fill">Cairo.fill</a> if you want it cleared.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">stride</span>: the number of bytes between the start of rows in
the buffer as allocated. This value should always be computed by
<a href="index.html#val-stride_for_width">stride_for_width</a> before allocating the data buffer. (that's
what this function does if the argument is not provided).</li></ul></div></div><div class="spec val" id="val-create_for_data32"><a href="#val-create_for_data32" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>create_for_data32 : ?&#8288;w:int <span class="keyword">&#8209;&gt;</span> ?&#8288;h:int <span class="keyword">&#8209;&gt;</span> ?&#8288;alpha:bool <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-data32">data32</a> <span class="keyword">&#8209;&gt;</span> <a href="../Surface/index.html#type-t">Surface.t</a></code></div><div class="doc"><p><code class="code">create_for_data32 ?w ?h ?alpha data</code> same as
<a href="index.html#val-create_for_data8">Cairo.Image.create_for_data8</a> except that the stride will
necessarily be according to the bigarray 1st dimension (so that
matrix coordinates correspond to pixels) and the width <code class="code">w</code> and
height <code class="code">h</code> will be by default taken from the bigarray 1st and 2nd
dimensions respectively. If <code class="code">alpha</code> is true (default), the
<code class="code">ARGB32</code> format is selected, otherwise <code class="code">RGB24</code> is used.</p></div></div><div class="spec val" id="val-get_data8"><a href="#val-get_data8" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_data8 : <a href="../Surface/index.html#type-t">Surface.t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-data8">data8</a></code></div><div class="doc"><p>Get the data of the image surface (shared), for direct
inspection or modification. A call to <a href="../Surface/index.html#val-mark_dirty">Cairo.Surface.mark_dirty</a>
or <a href="../Surface/index.html#val-mark_dirty_rectangle">Cairo.Surface.mark_dirty_rectangle</a> is required after the
data is modified.</p></div></div><div class="spec val" id="val-get_data32"><a href="#val-get_data32" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_data32 : <a href="../Surface/index.html#type-t">Surface.t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-data32">data32</a></code></div><div class="doc"><p>Get the data of the image surface (shared), for direct
inspection or modification. The 1st (resp. 2nd) dimension of the
bigarray correspond to the height (resp. width) of the surface. A
call to <a href="../Surface/index.html#val-mark_dirty">Cairo.Surface.mark_dirty</a> or
<a href="../Surface/index.html#val-mark_dirty_rectangle">Cairo.Surface.mark_dirty_rectangle</a> is required after the data
is modified.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if the format is not <code class="code">ARGB32</code> or
<code class="code">RGB24</code> because the array dimensions would not reflect the image
coordinates.</li></ul></div></div><div class="spec val" id="val-get_format"><a href="#val-get_format" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_format : <a href="../Surface/index.html#type-t">Surface.t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-format">format</a></code></div><div class="doc"><p>Get the format of the image surface.</p></div></div><div class="spec val" id="val-get_width"><a href="#val-get_width" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_width : <a href="../Surface/index.html#type-t">Surface.t</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p>Get the width of the image surface in pixels.</p></div></div><div class="spec val" id="val-get_height"><a href="#val-get_height" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_height : <a href="../Surface/index.html#type-t">Surface.t</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p>Get the height of the image surface in pixels.</p></div></div><div class="spec val" id="val-get_stride"><a href="#val-get_stride" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_stride : <a href="../Surface/index.html#type-t">Surface.t</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p>Get the stride of the image surface in bytes. Note that in
order to convert this stride in bytes to a stride in the
bigarray indices, the type of the surface has to be taken into
account: for <code class="code">ARGB32</code> and <code class="code">RGB24</code>, the stride has to be divided
by 4.</p></div></div><div class="spec val" id="val-stride_for_width"><a href="#val-stride_for_width" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>stride_for_width : <a href="index.html#type-format">format</a> <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">stride_for_width format w</code> a stride value that will respect
all alignment requirements of the accelerated image-rendering code
within cairo. See <a href="index.html#val-create_for_data8">create_for_data8</a>.</p></div></div><div class="spec val" id="val-output_ppm"><a href="#val-output_ppm" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>output_ppm : Pervasives.out_channel <span class="keyword">&#8209;&gt;</span> ?&#8288;w:int <span class="keyword">&#8209;&gt;</span> ?&#8288;h:int <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-data32">data32</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">output_ppm ch width height data</code> convenience function to write
the subarray of size (<code class="code">width</code>, <code class="code">height</code>) representing an image to
the PPM format. The possible alpha channel is ignored.</p></div></div></body></html>