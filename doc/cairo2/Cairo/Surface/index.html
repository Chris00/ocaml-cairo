<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Surface (cairo2.Cairo.Surface)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">cairo2</a> &#x00BB; <a href="../index.html">Cairo</a> &#x00BB; Surface</nav><h1>Module <code>Cairo.Surface</code></h1><p>Abstract representation of all different drawing targets that cairo can render to; the actual drawings are performed using a cairo context.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>A <a href="index.html#type-t"><code>Cairo.Surface.t</code></a> represents an image, either as the destination of a drawing operation or as source when drawing onto another surface. To draw to a <a href="index.html#type-t"><code>Cairo.Surface.t</code></a>, create a cairo context with the surface as the target, using <a href="../index.html#val-create"><code>Cairo.create</code></a>.</p><p>There are different subtypes of <a href="index.html#type-t"><code>Cairo.Surface.t</code></a> for different drawing backends; for example, <a href="../Image/index.html#val-create"><code>Cairo.Image.create</code></a> creates a bitmap image in memory. The type of a surface can be queried with <a href="index.html#val-get_type"><code>Cairo.Surface.get_type</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-create_similar"><a href="#val-create_similar" class="anchor"></a><code><span class="keyword">val</span> create_similar : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-content">content</a> <span>&#45;&gt;</span> <span>w:int</span> <span>&#45;&gt;</span> <span>h:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create_similar other content width height</code> create a new surface that is as compatible as possible with the existing surface <code>other</code>. For example the new surface will have the same fallback resolution and font options as <code>other</code>. Generally, the new surface will also use the same backend as other, unless that is not possible for some reason. The type of the returned surface may be examined with <a href="index.html#val-get_type"><code>Cairo.Surface.get_type</code></a>.</p><p>Initially the surface contents are all 0 (transparent if contents have transparency, black otherwise.)</p></dd></dl><dl><dt class="spec value" id="val-finish"><a href="#val-finish" class="anchor"></a><code><span class="keyword">val</span> finish : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>This function finishes the surface and drops all references to external resources. For example, for the Xlib backend it means that cairo will no longer access the drawable. After calling <a href="index.html#val-finish"><code>Cairo.Surface.finish</code></a> the only valid operations on a surface are flushing and finishing it. Further drawing to the surface will not affect the surface but will instead raise <code>Error(SURFACE_FINISHED)</code>.</p></dd></dl><dl><dt class="spec value" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span class="keyword">val</span> flush : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Do any pending drawing for the surface and also restore any temporary modification's cairo has made to the surface's state. This function must be called before switching from drawing on the surface with cairo to drawing on it directly with native APIs. If the surface doesn't support direct access, then this function does nothing.</p></dd></dl><dl><dt class="spec value" id="val-get_font_options"><a href="#val-get_font_options" class="anchor"></a><code><span class="keyword">val</span> get_font_options : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Font_options/index.html#type-t">Font_options.t</a></code></dt><dd><p><code>get_font_options surface</code> retrieves the default font rendering options for the <code>surface</code>. This allows display surfaces to report the correct subpixel order for rendering on them, print surfaces to disable hinting of metrics and so forth. The result can then be used with <a href="../Scaled_font/index.html#val-create"><code>Cairo.Scaled_font.create</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-get_content"><a href="#val-get_content" class="anchor"></a><code><span class="keyword">val</span> get_content : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-content">content</a></code></dt><dd><p>This function returns the content type of surface which indicates whether the surface contains color and/or alpha information. See <a href="../index.html#type-content"><code>Cairo.content</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-mark_dirty"><a href="#val-mark_dirty" class="anchor"></a><code><span class="keyword">val</span> mark_dirty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Tells cairo that drawing has been done to surface using means other than cairo, and that cairo should reread any cached areas. Note that you must call <a href="index.html#val-flush"><code>Cairo.Surface.flush</code></a> before doing such drawing.</p></dd></dl><dl><dt class="spec value" id="val-mark_dirty_rectangle"><a href="#val-mark_dirty_rectangle" class="anchor"></a><code><span class="keyword">val</span> mark_dirty_rectangle : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>w:int</span> <span>&#45;&gt;</span> <span>h:int</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>mark_dirty_rectangle x y w h</code> like <a href="index.html#val-mark_dirty"><code>Cairo.Surface.mark_dirty</code></a>, but drawing has been done only to the specified rectangle, so that cairo can retain cached contents for other parts of the surface.</p><p>Any cached clip set on the surface will be reset by this function, to make sure that future cairo calls have the clip set that they expect.</p></dd></dl><dl><dt class="spec value" id="val-set_device_offset"><a href="#val-set_device_offset" class="anchor"></a><code><span class="keyword">val</span> set_device_offset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface. One use case for this function is when we want to create a <a href="index.html#type-t"><code>Cairo.Surface.t</code></a> that redirects drawing for a portion of an onscreen surface to an offscreen surface in a way that is completely invisible to the user of the cairo API. Setting a transformation via <a href="../index.html#val-translate"><code>Cairo.translate</code></a> isn't sufficient to do this, since functions like <a href="../index.html#val-device_to_user"><code>Cairo.device_to_user</code></a> will expose the hidden offset.</p><p>Note that the offset affects drawing to the surface as well as using the surface in a source pattern.</p><dl><dt>parameter x</dt><dd><p>the offset in the X direction, in device units.</p></dd></dl><dl><dt>parameter y</dt><dd><p>the offset in the Y direction, in device units.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_device_offset"><a href="#val-get_device_offset" class="anchor"></a><code><span class="keyword">val</span> get_device_offset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float * float</code></dt><dd><p>This function returns the previous device offset set by <a href="index.html#val-set_device_offset"><code>Cairo.Surface.set_device_offset</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_fallback_resolution"><a href="#val-set_fallback_resolution" class="anchor"></a><code><span class="keyword">val</span> set_fallback_resolution : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>x:float</span> <span>&#45;&gt;</span> <span>y:float</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_fallback_resolution surface x_pixels_per_inch
     y_pixels_per_inch</code> sets the horizontal and vertical resolution for image fallbacks.</p><p>When certain operations aren't supported natively by a backend, cairo will fallback by rendering operations to an image and then overlaying that image onto the output. For backends that are natively vector-oriented, this function can be used to set the resolution used for these image fallbacks (larger values will result in more detailed images, but also larger file sizes).</p><p>Some examples of natively vector-oriented backends are the ps, pdf, and svg backends.</p><p>For backends that are natively raster-oriented, image fallbacks are still possible, but they are always performed at the native device resolution. So this function has no effect on those backends.</p><p>Note: The fallback resolution only takes effect at the time of completing a page (with <a href="../index.html#val-show_page"><code>Cairo.show_page</code></a> or <a href="../index.html#val-copy_page"><code>Cairo.copy_page</code></a>) so there is currently no way to have more than one fallback resolution in effect on a single page.</p><p>The default fallback resoultion is 300 pixels per inch in both dimensions.</p></dd></dl><dl><dt class="spec value" id="val-get_fallback_resolution"><a href="#val-get_fallback_resolution" class="anchor"></a><code><span class="keyword">val</span> get_fallback_resolution : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float * float</code></dt><dd><p>This function returns the previous fallback resolution set by <a href="index.html#val-set_fallback_resolution"><code>Cairo.Surface.set_fallback_resolution</code></a>, or default fallback resolution if never set.</p></dd></dl><dl><dt class="spec type" id="type-kind"><a href="#type-kind" class="anchor"></a><code><span class="keyword">type</span> kind</code> = <code>[ </code><table class="variant"><tr id="type-kind.Image" class="anchored"><td class="def constructor"><a href="#type-kind.Image" class="anchor"></a><code>| </code><code>`Image</code></td></tr><tr id="type-kind.PDF" class="anchored"><td class="def constructor"><a href="#type-kind.PDF" class="anchor"></a><code>| </code><code>`PDF</code></td></tr><tr id="type-kind.PS" class="anchored"><td class="def constructor"><a href="#type-kind.PS" class="anchor"></a><code>| </code><code>`PS</code></td></tr><tr id="type-kind.XLib" class="anchored"><td class="def constructor"><a href="#type-kind.XLib" class="anchor"></a><code>| </code><code>`XLib</code></td></tr><tr id="type-kind.XCB" class="anchored"><td class="def constructor"><a href="#type-kind.XCB" class="anchor"></a><code>| </code><code>`XCB</code></td></tr><tr id="type-kind.GLITZ" class="anchored"><td class="def constructor"><a href="#type-kind.GLITZ" class="anchor"></a><code>| </code><code>`GLITZ</code></td></tr><tr id="type-kind.Quartz" class="anchored"><td class="def constructor"><a href="#type-kind.Quartz" class="anchor"></a><code>| </code><code>`Quartz</code></td></tr><tr id="type-kind.Win32" class="anchored"><td class="def constructor"><a href="#type-kind.Win32" class="anchor"></a><code>| </code><code>`Win32</code></td></tr><tr id="type-kind.BEOS" class="anchored"><td class="def constructor"><a href="#type-kind.BEOS" class="anchor"></a><code>| </code><code>`BEOS</code></td></tr><tr id="type-kind.DirectFB" class="anchored"><td class="def constructor"><a href="#type-kind.DirectFB" class="anchor"></a><code>| </code><code>`DirectFB</code></td></tr><tr id="type-kind.SVG" class="anchored"><td class="def constructor"><a href="#type-kind.SVG" class="anchor"></a><code>| </code><code>`SVG</code></td></tr><tr id="type-kind.OS2" class="anchored"><td class="def constructor"><a href="#type-kind.OS2" class="anchor"></a><code>| </code><code>`OS2</code></td></tr><tr id="type-kind.Win32_printing" class="anchored"><td class="def constructor"><a href="#type-kind.Win32_printing" class="anchor"></a><code>| </code><code>`Win32_printing</code></td></tr><tr id="type-kind.Quartz_image" class="anchored"><td class="def constructor"><a href="#type-kind.Quartz_image" class="anchor"></a><code>| </code><code>`Quartz_image</code></td></tr><tr id="type-kind.Recording" class="anchored"><td class="def constructor"><a href="#type-kind.Recording" class="anchor"></a><code>| </code><code>`Recording</code></td></tr></table><code> ]</code></dt><dd><p>This is used to describe the type of a given surface. The surface types are also known as &quot;backends&quot; or &quot;surface backends&quot; within cairo.</p><p>The type of a surface is determined by the function used to create it, which will generally be of the form <code>cairo_</code><i>type</i><code>_surface_create</code> (though see <a href="index.html#val-create_similar"><code>Cairo.Surface.create_similar</code></a> as well).</p></dd></dl><dl><dt class="spec value" id="val-get_type"><a href="#val-get_type" class="anchor"></a><code><span class="keyword">val</span> get_type : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-kind">kind</a></code></dt><dd><p>This function returns the type of the backend used to create a surface. See <a href="index.html#type-kind"><code>Cairo.Surface.kind</code></a> for available types.</p></dd></dl><dl><dt class="spec value" id="val-copy_page"><a href="#val-copy_page" class="anchor"></a><code><span class="keyword">val</span> copy_page : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Emits the current page for backends that support multiple pages, but doesn't clear it, so that the contents of the current page will be retained for the next page. Use <a href="index.html#val-show_page"><code>Cairo.Surface.show_page</code></a> if you want to get an empty page after the emission.</p><p>There is a convenience function for this that takes a <a href="../index.html#type-context"><code>Cairo.context</code></a>, namely <a href="../index.html#val-copy_page"><code>Cairo.copy_page</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-show_page"><a href="#val-show_page" class="anchor"></a><code><span class="keyword">val</span> show_page : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Emits and clears the current page for backends that support multiple pages. Use <a href="index.html#val-copy_page"><code>Cairo.Surface.copy_page</code></a> if you don't want to clear the page.</p><p>There is a convenience function for this that takes a <a href="../index.html#type-context"><code>Cairo.context</code></a>, namely <a href="../index.html#val-show_page"><code>Cairo.show_page</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-has_show_text_glyphs"><a href="#val-has_show_text_glyphs" class="anchor"></a><code><span class="keyword">val</span> has_show_text_glyphs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns whether the surface supports sophisticated <a href="../Glyph/index.html#val-show_text"><code>Cairo.Glyph.show_text</code></a> operations. That is, whether it actually uses the provided text and cluster data to a <a href="../Glyph/index.html#val-show_text"><code>Cairo.Glyph.show_text</code></a> call.</p><p>Note: Even if this function returns <code>false</code>, a <a href="../Glyph/index.html#val-show_text"><code>Cairo.Glyph.show_text</code></a> operation targeted at surface will still succeed. It just will act like a <a href="../Glyph/index.html#val-show"><code>Cairo.Glyph.show</code></a> operation. Users can use this function to avoid computing UTF-8 text and cluster mapping if the target surface does not use it.</p></dd></dl></div></body></html>