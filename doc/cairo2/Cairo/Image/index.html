<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Image (cairo2.Cairo.Image)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">cairo2</a> &#x00BB; <a href="../index.html">Cairo</a> &#x00BB; Image</nav><header class="odoc-preamble"><h1>Module <code><span>Cairo.Image</span></code></h1><p>Image surfaces provide the ability to render to memory buffers either allocated by cairo or by the calling code. The supported image formats are those defined in <a href="#type-format"><code>Cairo.Image.format</code></a>.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-format" class="anchored"><a href="#type-format" class="anchor"></a><code><span><span class="keyword">type</span> format</span><span> = </span></code><table><tr id="type-format.ARGB32" class="anchored"><td class="def variant constructor"><a href="#type-format.ARGB32" class="anchor"></a><code><span>| </span><span><span class="constructor">ARGB32</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>each pixel is a 32-bit quantity, with alpha in the upper 8 bits, then red, then green, then blue. The 32-bit quantities are stored native-endian. Pre-multiplied alpha is used. (That is, 50% transparent red is 0x80800000, not 0x80ff0000.)</p><span class="comment-delim">*)</span></td></tr><tr id="type-format.RGB24" class="anchored"><td class="def variant constructor"><a href="#type-format.RGB24" class="anchor"></a><code><span>| </span><span><span class="constructor">RGB24</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>each pixel is a 32-bit quantity, with the upper 8 bits unused. Red, Green, and Blue are stored in the remaining 24 bits in that order.</p><span class="comment-delim">*)</span></td></tr><tr id="type-format.A8" class="anchored"><td class="def variant constructor"><a href="#type-format.A8" class="anchor"></a><code><span>| </span><span><span class="constructor">A8</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>each pixel is a 8-bit quantity holding an alpha value.</p><span class="comment-delim">*)</span></td></tr><tr id="type-format.A1" class="anchored"><td class="def variant constructor"><a href="#type-format.A1" class="anchor"></a><code><span>| </span><span><span class="constructor">A1</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>each pixel is a 1-bit quantity holding an alpha value. Pixels are packed together into 32-bit quantities. The ordering of the bits matches the endianess of the platform. On a big-endian machine, the first pixel is in the uppermost bit, on a little-endian machine the first pixel is in the least-significant bit.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>This is used to identify the memory format of image data.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><a href="#type-format">format</a> <span class="arrow">&#45;&gt;</span></span> <span>w:int <span class="arrow">&#45;&gt;</span></span> <span>h:int <span class="arrow">&#45;&gt;</span></span> <a href="../Surface/index.html#type-t">Surface.t</a></span></code></div><div class="spec-doc"><p>Creates an image surface of the specified format and dimensions. Initially the surface contents are all 0. (Specifically, within each pixel, each color or alpha channel belonging to format will be 0. The contents of bits within a pixel, but not belonging to the given format are undefined).</p></div></div><div class="odoc-spec"><div class="spec type" id="type-data8" class="anchored"><a href="#type-data8" class="anchor"></a><code><span><span class="keyword">type</span> data8</span><span> =
  <span><span>( int, <span class="xref-unresolved">Stdlib</span>.Bigarray.int8_unsigned_elt, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout )</span>
    <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span></span></code></div><div class="spec-doc"><p>Images represented as an array of 8 bytes values.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-data32" class="anchored"><a href="#type-data32" class="anchor"></a><code><span><span class="keyword">type</span> data32</span><span> =
  <span><span>( int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout )</span>
    <span class="xref-unresolved">Stdlib</span>.Bigarray.Array2.t</span></span></code></div><div class="spec-doc"><p>Images represented as an array of 32 bytes (RGB or RGBA) values.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_for_data8" class="anchored"><a href="#val-create_for_data8" class="anchor"></a><code><span><span class="keyword">val</span> create_for_data8 : 
  <span><a href="#type-data8">data8</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?stride:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-format">format</a> <span class="arrow">&#45;&gt;</span></span>
  <span>w:int <span class="arrow">&#45;&gt;</span></span>
  <span>h:int <span class="arrow">&#45;&gt;</span></span>
  <a href="../Surface/index.html#type-t">Surface.t</a></span></code></div><div class="spec-doc"><p><code>create_for_data8 data format ?stride width height</code> creates an image surface for the provided pixel data. The initial contents of buffer will be used as the initial image contents; you must explicitly clear the buffer, using, for example, <a href="../index.html#type-rectangle"><code>Cairo.rectangle</code></a> and <a href="../index.html#val-fill"><code>Cairo.fill</code></a> if you want it cleared.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">stride</span> <p>the number of bytes between the start of rows in the buffer as allocated. This value should always be computed by <code>stride_for_width</code> before allocating the data buffer. (that's what this function does if the argument is not provided).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-create_for_data32" class="anchored"><a href="#val-create_for_data32" class="anchor"></a><code><span><span class="keyword">val</span> create_for_data32 : <span>?w:int <span class="arrow">&#45;&gt;</span></span> <span>?h:int <span class="arrow">&#45;&gt;</span></span> <span>?alpha:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-data32">data32</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Surface/index.html#type-t">Surface.t</a></span></code></div><div class="spec-doc"><p><code>create_for_data32 ?w ?h ?alpha data</code> same as <a href="#val-create_for_data8"><code>Cairo.Image.create_for_data8</code></a> except that the stride will be set so that <code>data.{y,x}</code> refers to the pixel (<code>x</code>,<code>y</code>) (where (0,0) is the top left pixel and the Y axis is directed downwards).</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">w</span> <p>the width of the image (default: <code>Array2.dim2 data</code>).</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">h</span> <p>the height of the image (default: <code>Array2.dim1 data</code>).</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">alpha</span> <p>if true (default), the <code>ARGB32</code> format is selected, otherwise <code>RGB24</code> is used.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-get_data8" class="anchored"><a href="#val-get_data8" class="anchor"></a><code><span><span class="keyword">val</span> get_data8 : <span><a href="../Surface/index.html#type-t">Surface.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-data8">data8</a></span></code></div><div class="spec-doc"><p>Get the data of the image surface (shared), for direct inspection or modification. A call to <a href="../Surface/index.html#val-mark_dirty"><code>Cairo.Surface.mark_dirty</code></a> or <a href="../Surface/index.html#val-mark_dirty_rectangle"><code>Cairo.Surface.mark_dirty_rectangle</code></a> is required after the data is modified.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_data32" class="anchored"><a href="#val-get_data32" class="anchor"></a><code><span><span class="keyword">val</span> get_data32 : <span><a href="../Surface/index.html#type-t">Surface.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-data32">data32</a></span></code></div><div class="spec-doc"><p>Get the data of the image surface (shared), for direct inspection or modification. The 1st (resp. 2nd) dimension of the bigarray correspond to the height (resp. width) of the surface. A call to <a href="../Surface/index.html#val-mark_dirty"><code>Cairo.Surface.mark_dirty</code></a> or <a href="../Surface/index.html#val-mark_dirty_rectangle"><code>Cairo.Surface.mark_dirty_rectangle</code></a> is required after the data is modified.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the format is not <code>ARGB32</code> or <code>RGB24</code> because the array dimensions would not reflect the image coordinates.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-get_format" class="anchored"><a href="#val-get_format" class="anchor"></a><code><span><span class="keyword">val</span> get_format : <span><a href="../Surface/index.html#type-t">Surface.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-format">format</a></span></code></div><div class="spec-doc"><p>Get the format of the image surface.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_width" class="anchored"><a href="#val-get_width" class="anchor"></a><code><span><span class="keyword">val</span> get_width : <span><a href="../Surface/index.html#type-t">Surface.t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Get the width of the image surface in pixels.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_height" class="anchored"><a href="#val-get_height" class="anchor"></a><code><span><span class="keyword">val</span> get_height : <span><a href="../Surface/index.html#type-t">Surface.t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Get the height of the image surface in pixels.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_stride" class="anchored"><a href="#val-get_stride" class="anchor"></a><code><span><span class="keyword">val</span> get_stride : <span><a href="../Surface/index.html#type-t">Surface.t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Get the stride of the image surface in bytes. Note that in order to convert this stride in bytes to a stride in the bigarray indices, the type of the surface has to be taken into account: for <code>ARGB32</code> and <code>RGB24</code>, the stride has to be divided by 4.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stride_for_width" class="anchored"><a href="#val-stride_for_width" class="anchor"></a><code><span><span class="keyword">val</span> stride_for_width : <span><a href="#type-format">format</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>stride_for_width format w</code> a stride value that will respect all alignment requirements of the accelerated image-rendering code within cairo. See <a href="#val-create_for_data8"><code>create_for_data8</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-output_ppm" class="anchored"><a href="#val-output_ppm" class="anchor"></a><code><span><span class="keyword">val</span> output_ppm : <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span>?w:int <span class="arrow">&#45;&gt;</span></span> <span>?h:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-data32">data32</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>output_ppm ch width height data</code> convenience function to write the subarray of size (<code>width</code>, <code>height</code>) representing an image to the PPM format. The possible alpha channel is ignored.</p></div></div></div></body></html>