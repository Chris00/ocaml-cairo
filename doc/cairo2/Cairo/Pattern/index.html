<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pattern (cairo2.Cairo.Pattern)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">cairo2</a> &#x00BB; <a href="../index.html">Cairo</a> &#x00BB; Pattern</nav><header class="odoc-preamble"><h1>Module <code><span>Cairo.Pattern</span></code></h1><p>Paint (and also mask and brush) with which cairo draws and associated function.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> <span class="keyword">constraint</span> <span class="type-var">'a</span> = <span>[&lt; `Solid <span>| `Surface</span> <span>| `Gradient</span> <span>| `Linear</span> <span>| `Radial</span> ]</span></span></code></div><div class="spec-doc"><p>This is the paint with which cairo draws. The primary use of patterns is as the source for all cairo drawing operations, although they can also be used as masks, that is, as the brush too.</p><p>A cairo pattern is created by using one of the many functions, of the form <code>Cairo.Pattern.create_type</code> or implicitly through <code>Cairo.set_source_*</code> functions.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-any" class="anchored"><a href="#type-any" class="anchor"></a><code><span><span class="keyword">type</span> any</span><span> = <span><span>[ `Solid <span>| `Surface</span> <span>| `Gradient</span> <span>| `Linear</span> <span>| `Radial</span> ]</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><a href="../Group/index.html#val-pop"><code>Cairo.Group.pop</code></a> and <a href="../index.html#val-get_source"><code>Cairo.get_source</code></a> retrieve patterns whose properties we do not know. In this case, we can only assume the pattern has potentially all properties and the functions below may raise an exception if it turns out that the needed property is not present.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_color_stop_rgb" class="anchored"><a href="#val-add_color_stop_rgb" class="anchor"></a><code><span><span class="keyword">val</span> add_color_stop_rgb : 
  <span><span><span>[&gt; `Gradient ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?ofs:float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Adds an opaque color stop to a gradient pattern. The offset <code>ofs</code> specifies the location along the gradient's control vector (default: <code>0.0</code>). For example, a linear gradient's control vector is from (x0,y0) to (x1,y1) while a radial gradient's control vector is from any point on the start circle to the corresponding point on the end circle.</p><p>The color is specified in the same way as in <a href="../index.html#val-set_source_rgb"><code>Cairo.set_source_rgb</code></a>.</p><p>If two (or more) stops are specified with identical offset values, they will be sorted according to the order in which the stops are added (stops added earlier will compare less than stops added later). This can be useful for reliably making sharp color transitions instead of the typical blend.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_color_stop_rgba" class="anchored"><a href="#val-add_color_stop_rgba" class="anchor"></a><code><span><span class="keyword">val</span> add_color_stop_rgba : 
  <span><span><span>[&gt; `Gradient ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?ofs:float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Adds a translucent color stop to a gradient pattern. The offset specifies the location along the gradient's control vector. For example, a linear gradient's control vector is from (x0,y0) to (x1,y1) while a radial gradient's control vector is from any point on the start circle to the corresponding point on the end circle.</p><p>The color is specified in the same way as in <a href="../index.html#val-set_source_rgba"><code>Cairo.set_source_rgba</code></a>.</p><p>If two (or more) stops are specified with identical offset values, they will be sorted according to the order in which the stops are added (stops added earlier will compare less than stops added later). This can be useful for reliably making sharp color transitions instead of the typical blend.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_color_stop_count" class="anchored"><a href="#val-get_color_stop_count" class="anchor"></a><code><span><span class="keyword">val</span> get_color_stop_count : <span><span><span>[&gt; `Gradient ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the number of color stops specified in the given gradient pattern.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_color_stop_rgba" class="anchored"><a href="#val-get_color_stop_rgba" class="anchor"></a><code><span><span class="keyword">val</span> get_color_stop_rgba : 
  <span><span><span>[&gt; `Gradient ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>idx:int <span class="arrow">&#45;&gt;</span></span>
  float * float * float * float * float</span></code></div><div class="spec-doc"><p>Gets the color and offset information at the given index for a gradient pattern. Values of index are 0 to 1 less than the number returned by <a href="#val-get_color_stop_count"><code>Cairo.Pattern.get_color_stop_count</code></a>.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>(offset, red, green, blue, alpha)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-create_rgb" class="anchored"><a href="#val-create_rgb" class="anchor"></a><code><span><span class="keyword">val</span> create_rgb : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><span>[ `Solid ]</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create_rgb r g b</code> creates a new <a href="#type-t"><code>Cairo.Pattern.t</code></a> corresponding to an opaque color. The color components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_rgba" class="anchored"><a href="#val-create_rgba" class="anchor"></a><code><span><span class="keyword">val</span> create_rgba : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><span>[ `Solid ]</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create_rgba r g b a</code> creates a new <a href="#type-t"><code>Cairo.Pattern.t</code></a> corresponding to a translucent color. The color components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_rgba" class="anchored"><a href="#val-get_rgba" class="anchor"></a><code><span><span class="keyword">val</span> get_rgba : <span><span><span>[&gt; `Solid ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float * float * float * float</span></code></div><div class="spec-doc"><p>Return the solid color for a solid color pattern.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>(red, green, blue, alpha)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-create_for_surface" class="anchored"><a href="#val-create_for_surface" class="anchor"></a><code><span><span class="keyword">val</span> create_for_surface : <span><a href="../Surface/index.html#type-t">Surface.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>[ `Surface ]</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Create a new <a href="#type-t"><code>Cairo.Pattern.t</code></a> for the given surface.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_surface" class="anchored"><a href="#val-get_surface" class="anchor"></a><code><span><span class="keyword">val</span> get_surface : <span><span><span>[ `Surface ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Surface/index.html#type-t">Surface.t</a></span></code></div><div class="spec-doc"><p>Gets the surface of a surface pattern.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_linear" class="anchored"><a href="#val-create_linear" class="anchor"></a><code><span><span class="keyword">val</span> create_linear : 
  <span>x0:float <span class="arrow">&#45;&gt;</span></span>
  <span>y0:float <span class="arrow">&#45;&gt;</span></span>
  <span>x1:float <span class="arrow">&#45;&gt;</span></span>
  <span>y1:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Linear <span>| `Gradient</span> ]</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Create a new linear gradient <a href="#type-t"><code>Cairo.Pattern.t</code></a> along the line defined by (x0, y0) and (x1, y1). Before using the gradient pattern, a number of color stops should be defined using <a href="#val-add_color_stop_rgb"><code>Cairo.Pattern.add_color_stop_rgb</code></a> or <a href="#val-add_color_stop_rgba"><code>Cairo.Pattern.add_color_stop_rgba</code></a>.</p><p>Note: The coordinates here are in pattern space. For a new pattern, pattern space is identical to user space, but the relationship between the spaces can be changed with <a href="#val-set_matrix"><code>Cairo.Pattern.set_matrix</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_linear_points" class="anchored"><a href="#val-get_linear_points" class="anchor"></a><code><span><span class="keyword">val</span> get_linear_points : 
  <span><span><span>[&gt; `Linear <span>| `Gradient</span> ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  float * float * float * float</span></code></div><div class="spec-doc"><p>Gets the gradient endpoints for a linear gradient.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>(x0, y0, x1, y1).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-create_radial" class="anchored"><a href="#val-create_radial" class="anchor"></a><code><span><span class="keyword">val</span> create_radial : 
  <span>x0:float <span class="arrow">&#45;&gt;</span></span>
  <span>y0:float <span class="arrow">&#45;&gt;</span></span>
  <span>r0:float <span class="arrow">&#45;&gt;</span></span>
  <span>x1:float <span class="arrow">&#45;&gt;</span></span>
  <span>y1:float <span class="arrow">&#45;&gt;</span></span>
  <span>r1:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Radial <span>| `Gradient</span> ]</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Creates a new radial gradient <a href="#type-t"><code>Cairo.Pattern.t</code></a> between the two circles defined by (cx0, cy0, radius0) and (cx1, cy1, radius1). Before using the gradient pattern, a number of color stops should be defined using <a href="#val-add_color_stop_rgb"><code>Cairo.Pattern.add_color_stop_rgb</code></a> or <a href="#val-add_color_stop_rgba"><code>Cairo.Pattern.add_color_stop_rgba</code></a>.</p><p>Note: The coordinates here are in pattern space. For a new pattern, pattern space is identical to user space, but the relationship between the spaces can be changed with <a href="#val-set_matrix"><code>Cairo.Pattern.set_matrix</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_radial_circles" class="anchored"><a href="#val-get_radial_circles" class="anchor"></a><code><span><span class="keyword">val</span> get_radial_circles : 
  <span><span><span>[&gt; `Radial <span>| `Gradient</span> ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  float * float * float * float * float * float</span></code></div><div class="spec-doc"><p>Gets the gradient endpoint circles for a radial gradient, each specified as a center coordinate and a radius.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>(x0, y0, r0, x1, y1, r1).</p></li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-extend" class="anchored"><a href="#type-extend" class="anchor"></a><code><span><span class="keyword">type</span> extend</span><span> = </span></code><table><tr id="type-extend.NONE" class="anchored"><td class="def variant constructor"><a href="#type-extend.NONE" class="anchor"></a><code><span>| </span><span><span class="constructor">NONE</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>pixels outside of the source pattern are fully transparent.</p><span class="comment-delim">*)</span></td></tr><tr id="type-extend.REPEAT" class="anchored"><td class="def variant constructor"><a href="#type-extend.REPEAT" class="anchor"></a><code><span>| </span><span><span class="constructor">REPEAT</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>the pattern is tiled by repeating.</p><span class="comment-delim">*)</span></td></tr><tr id="type-extend.REFLECT" class="anchored"><td class="def variant constructor"><a href="#type-extend.REFLECT" class="anchor"></a><code><span>| </span><span><span class="constructor">REFLECT</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>the pattern is tiled by reflecting at the edges.</p><span class="comment-delim">*)</span></td></tr><tr id="type-extend.PAD" class="anchored"><td class="def variant constructor"><a href="#type-extend.PAD" class="anchor"></a><code><span>| </span><span><span class="constructor">PAD</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>pixels outside of the pattern copy the closest pixel from the source.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>This is used to describe how pattern color/alpha will be determined for areas &quot;outside&quot; the pattern's natural area (for example, outside the surface bounds or outside the gradient geometry).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_extend" class="anchored"><a href="#val-set_extend" class="anchor"></a><code><span><span class="keyword">val</span> set_extend : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-extend">extend</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Sets the mode to be used for drawing outside the area of a pattern. See <a href="#type-extend"><code>Cairo.Pattern.extend</code></a> for details on the semantics of each extend strategy.</p><p>The default extend mode is <code>NONE</code> for surface patterns and <code>PAD</code> for gradient patterns.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_extend" class="anchored"><a href="#val-get_extend" class="anchor"></a><code><span><span class="keyword">val</span> get_extend : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-extend">extend</a></span></code></div><div class="spec-doc"><p>Gets the current extend mode for a pattern. See <a href="#type-extend"><code>Cairo.Pattern.extend</code></a> for details on the semantics of each extend strategy.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-filter" class="anchored"><a href="#type-filter" class="anchor"></a><code><span><span class="keyword">type</span> filter</span><span> = </span></code><table><tr id="type-filter.FAST" class="anchored"><td class="def variant constructor"><a href="#type-filter.FAST" class="anchor"></a><code><span>| </span><span><span class="constructor">FAST</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A high-performance filter, with quality similar to NEAREST</p><span class="comment-delim">*)</span></td></tr><tr id="type-filter.GOOD" class="anchored"><td class="def variant constructor"><a href="#type-filter.GOOD" class="anchor"></a><code><span>| </span><span><span class="constructor">GOOD</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A reasonable-performance filter, with quality similar to BILINEAR</p><span class="comment-delim">*)</span></td></tr><tr id="type-filter.BEST" class="anchored"><td class="def variant constructor"><a href="#type-filter.BEST" class="anchor"></a><code><span>| </span><span><span class="constructor">BEST</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The highest-quality available, performance may not be suitable for interactive use.</p><span class="comment-delim">*)</span></td></tr><tr id="type-filter.NEAREST" class="anchored"><td class="def variant constructor"><a href="#type-filter.NEAREST" class="anchor"></a><code><span>| </span><span><span class="constructor">NEAREST</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Nearest-neighbor filtering</p><span class="comment-delim">*)</span></td></tr><tr id="type-filter.BILINEAR" class="anchored"><td class="def variant constructor"><a href="#type-filter.BILINEAR" class="anchor"></a><code><span>| </span><span><span class="constructor">BILINEAR</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Linear interpolation in two dimensions</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>This is used to indicate what filtering should be applied when reading pixel values from patterns. See <a href="#val-set_filter"><code>Cairo.Pattern.set_filter</code></a> for indicating the desired filter to be used with a particular pattern.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_filter" class="anchored"><a href="#val-set_filter" class="anchor"></a><code><span><span class="keyword">val</span> set_filter : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-filter">filter</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Sets the filter to be used for resizing when using this pattern. See <a href="#type-filter"><code>Cairo.Pattern.filter</code></a> for details on each filter.</p><p>Note that you might want to control filtering even when you do not have an explicit <a href="#type-t"><code>Cairo.Pattern.t</code></a> value (for example when using <a href="../index.html#val-set_source_surface"><code>Cairo.set_source_surface</code></a>). In these cases, it is convenient to use <a href="../index.html#val-get_source"><code>Cairo.get_source</code></a> to get access to the pattern that cairo creates implicitly. For example:</p><pre><code>Cairo.set_source_surface cr image x y;
Cairo.Pattern.set_filter (Cairo.get_source cr) Cairo.Pattern.NEAREST;</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-get_filter" class="anchored"><a href="#val-get_filter" class="anchor"></a><code><span><span class="keyword">val</span> get_filter : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-filter">filter</a></span></code></div><div class="spec-doc"><p>Gets the current filter for a pattern. See <a href="#type-filter"><code>Cairo.Pattern.filter</code></a> for details on each filter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_matrix" class="anchored"><a href="#val-set_matrix" class="anchor"></a><code><span><span class="keyword">val</span> set_matrix : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Matrix/index.html#type-t">Matrix.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Sets the pattern's transformation matrix to matrix. This matrix is a transformation from user space to pattern space.</p><p>When a pattern is first created it always has the identity matrix for its transformation matrix, which means that pattern space is initially identical to user space.</p><p>Important: Please note that the direction of this transformation matrix is from user space to pattern space. This means that if you imagine the flow from a pattern to user space (and on to device space), then coordinates in that flow will be transformed by the inverse of the pattern matrix.</p><p>For example, if you want to make a pattern appear twice as large as it does by default the correct code to use is:</p><pre><code>let matrix = Cairo.Matrix.init_scale 0.5 0.5 in
Cairo.Pattern.set_matrix pattern matrix;</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-get_matrix" class="anchored"><a href="#val-get_matrix" class="anchor"></a><code><span><span class="keyword">val</span> get_matrix : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Matrix/index.html#type-t">Matrix.t</a></span></code></div><div class="spec-doc"><p>Returns the pattern's transformation matrix.</p></div></div></div></body></html>