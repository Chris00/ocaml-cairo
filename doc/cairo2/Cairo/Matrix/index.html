<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Matrix (cairo2.Cairo.Matrix)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">cairo2</a> &#x00BB; <a href="../index.html">Cairo</a> &#x00BB; Matrix</nav><h1>Module <code>Cairo.Matrix</code></h1><p>This is used throughout cairo to convert between different coordinate spaces.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../index.html#type-matrix">matrix</a></code></dt></dl><dl><dt class="spec value" id="val-init_identity"><a href="#val-init_identity" class="anchor"></a><code><span class="keyword">val</span> init_identity : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init_identity()</code> returns the identity transformation.</p></dd></dl><dl><dt class="spec value" id="val-init_translate"><a href="#val-init_translate" class="anchor"></a><code><span class="keyword">val</span> init_translate : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init_translate tx ty</code> return a transformation that translates by <code>tx</code> and <code>ty</code> in the X and Y dimensions, respectively.</p></dd></dl><dl><dt class="spec value" id="val-init_scale"><a href="#val-init_scale" class="anchor"></a><code><span class="keyword">val</span> init_scale : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init_scale sx sy</code> return a transformation that scales by <code>sx</code> and <code>sy</code> in the X and Y dimensions, respectively.</p></dd></dl><dl><dt class="spec value" id="val-init_rotate"><a href="#val-init_rotate" class="anchor"></a><code><span class="keyword">val</span> init_rotate : float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init_rotate radians</code> returns a a transformation that rotates by <code>radians</code>.</p></dd></dl><dl><dt class="spec value" id="val-translate"><a href="#val-translate" class="anchor"></a><code><span class="keyword">val</span> translate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>translate matrix tx ty</code> applies a translation by <code>tx</code>, <code>ty</code> to the transformation in <code>matrix</code>. The effect of the new transformation is to first translate the coordinates by <code>tx</code> and <code>ty</code>, then apply the original transformation to the coordinates.</p></dd></dl><dl><dt class="spec value" id="val-scale"><a href="#val-scale" class="anchor"></a><code><span class="keyword">val</span> scale : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scale matrix sx sy</code> applies scaling by <code>sx</code>, <code>sy</code> to the transformation in <code>matrix</code>. The effect of the new transformation is to first scale the coordinates by <code>sx</code> and <code>sy</code>, then apply the original transformation to the coordinates.</p></dd></dl><dl><dt class="spec value" id="val-rotate"><a href="#val-rotate" class="anchor"></a><code><span class="keyword">val</span> rotate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>rotate matrix radians</code> applies rotation by <code>radians</code> to the transformation in <code>matrix</code>. The effect of the new transformation is to first rotate the coordinates by <code>radians</code>, then apply the original transformation to the coordinates.</p></dd></dl><dl><dt class="spec value" id="val-invert"><a href="#val-invert" class="anchor"></a><code><span class="keyword">val</span> invert : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>invert matrix</code> changes <code>matrix</code> to be the inverse of it's original value. Not all transformation matrices have inverses; if the matrix collapses points together (it is degenerate), then it has no inverse and this function will raise <code>Error
     INVALID_MATRIX</code>.</p></dd></dl><dl><dt class="spec value" id="val-multiply"><a href="#val-multiply" class="anchor"></a><code><span class="keyword">val</span> multiply : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>multiply a b</code> multiplies the affine transformations in <code>a</code> and <code>b</code> together and return the result. The effect of the resulting transformation is to first apply the transformation in <code>a</code> to the coordinates and then apply the transformation in <code>b</code> to the coordinates.</p></dd></dl><dl><dt class="spec value" id="val-transform_distance"><a href="#val-transform_distance" class="anchor"></a><code><span class="keyword">val</span> transform_distance : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> dx:float <span>&#45;&gt;</span> dy:float <span>&#45;&gt;</span> float * float</code></dt><dd><p><code>transform_distance matrix dx dy</code> transforms the distance vector (<code>dx</code>,<code>dy</code>) by <code>matrix</code>. This is similar to <a href="index.html#val-transform_point"><code>Cairo.Matrix.transform_point</code></a> except that the translation components of the transformation are ignored. The calculation of the returned vector is as follows:</p><pre><code class="ml">dx2 = dx1 * a + dy1 * c;
dy2 = dx1 * b + dy1 * d;</code></pre><p>Affine transformations are position invariant, so the same vector always transforms to the same vector. If (x1,y1) transforms to (x2,y2) then (x1+dx1,y1+dy1) will transform to (x1+dx2,y1+dy2) for all values of x1 and x2.</p></dd></dl><dl><dt class="spec value" id="val-transform_point"><a href="#val-transform_point" class="anchor"></a><code><span class="keyword">val</span> transform_point : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float * float</code></dt><dd><p><code>transform_point matrix x y</code> transforms the point (<code>x</code>, <code>y</code>) by <code>matrix</code>.</p></dd></dl></div></body></html>