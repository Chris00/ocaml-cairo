<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Matrix (cairo2.Cairo.Matrix)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">cairo2</a> &#x00BB; <a href="../index.html">Cairo</a> &#x00BB; Matrix</nav><header class="odoc-preamble"><h1>Module <code><span>Cairo.Matrix</span></code></h1><p>This is used throughout cairo to convert between different coordinate spaces.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../index.html#type-matrix">matrix</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-init_identity" class="anchored"><a href="#val-init_identity" class="anchor"></a><code><span><span class="keyword">val</span> init_identity : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>init_identity()</code> returns the identity transformation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init_translate" class="anchored"><a href="#val-init_translate" class="anchor"></a><code><span><span class="keyword">val</span> init_translate : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>init_translate tx ty</code> return a transformation that translates by <code>tx</code> and <code>ty</code> in the X and Y dimensions, respectively.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init_scale" class="anchored"><a href="#val-init_scale" class="anchor"></a><code><span><span class="keyword">val</span> init_scale : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>init_scale sx sy</code> return a transformation that scales by <code>sx</code> and <code>sy</code> in the X and Y dimensions, respectively.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init_rotate" class="anchored"><a href="#val-init_rotate" class="anchor"></a><code><span><span class="keyword">val</span> init_rotate : <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>init_rotate radians</code> returns a a transformation that rotates by <code>radians</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-translate" class="anchored"><a href="#val-translate" class="anchor"></a><code><span><span class="keyword">val</span> translate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>translate matrix tx ty</code> applies a translation by <code>tx</code>, <code>ty</code> to the transformation in <code>matrix</code>. The effect of the new transformation is to first translate the coordinates by <code>tx</code> and <code>ty</code>, then apply the original transformation to the coordinates.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scale" class="anchored"><a href="#val-scale" class="anchor"></a><code><span><span class="keyword">val</span> scale : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>scale matrix sx sy</code> applies scaling by <code>sx</code>, <code>sy</code> to the transformation in <code>matrix</code>. The effect of the new transformation is to first scale the coordinates by <code>sx</code> and <code>sy</code>, then apply the original transformation to the coordinates.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rotate" class="anchored"><a href="#val-rotate" class="anchor"></a><code><span><span class="keyword">val</span> rotate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>rotate matrix radians</code> applies rotation by <code>radians</code> to the transformation in <code>matrix</code>. The effect of the new transformation is to first rotate the coordinates by <code>radians</code>, then apply the original transformation to the coordinates.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-invert" class="anchored"><a href="#val-invert" class="anchor"></a><code><span><span class="keyword">val</span> invert : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>invert matrix</code> changes <code>matrix</code> to be the inverse of it's original value. Not all transformation matrices have inverses; if the matrix collapses points together (it is degenerate), then it has no inverse and this function will raise <code>Error
     INVALID_MATRIX</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-multiply" class="anchored"><a href="#val-multiply" class="anchor"></a><code><span><span class="keyword">val</span> multiply : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>multiply a b</code> multiplies the affine transformations in <code>a</code> and <code>b</code> together and return the result. The effect of the resulting transformation is to first apply the transformation in <code>a</code> to the coordinates and then apply the transformation in <code>b</code> to the coordinates.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-transform_distance" class="anchored"><a href="#val-transform_distance" class="anchor"></a><code><span><span class="keyword">val</span> transform_distance : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>dx:float <span class="arrow">&#45;&gt;</span></span> <span>dy:float <span class="arrow">&#45;&gt;</span></span> float * float</span></code></div><div class="spec-doc"><p><code>transform_distance matrix dx dy</code> transforms the distance vector (<code>dx</code>,<code>dy</code>) by <code>matrix</code>. This is similar to <a href="#val-transform_point"><code>Cairo.Matrix.transform_point</code></a> except that the translation components of the transformation are ignored. The calculation of the returned vector is as follows:</p><pre><code>dx2 = dx1 * a + dy1 * c;
dy2 = dx1 * b + dy1 * d;</code></pre><p>Affine transformations are position invariant, so the same vector always transforms to the same vector. If (x1,y1) transforms to (x2,y2) then (x1+dx1,y1+dy1) will transform to (x1+dx2,y1+dy2) for all values of x1 and x2.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-transform_point" class="anchored"><a href="#val-transform_point" class="anchor"></a><code><span><span class="keyword">val</span> transform_point : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float * float</span></code></div><div class="spec-doc"><p><code>transform_point matrix x y</code> transforms the point (<code>x</code>, <code>y</code>) by <code>matrix</code>.</p></div></div></div></body></html>